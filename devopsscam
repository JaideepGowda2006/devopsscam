

## **1Ô∏è‚É£ Program: Stack using Array (Push and Display)**

### **Algorithm**

```
Step 1: Start
Step 2: Initialize TOP = -1 and define MAX size of the stack
Step 3: To PUSH an element:
        a. Check if TOP == MAX - 1
           ‚Üí If yes, display "Stack Overflow"
        b. Else, increment TOP by 1
        c. Insert the new element at stack[TOP]
Step 4: To DISPLAY elements:
        a. If TOP == -1, display "Stack is empty"
        b. Else, print all elements from stack[TOP] down to stack[0]
Step 5: Stop
```

### **C Program**

```c
#include <stdio.h>
#define MAX 100

int stack[MAX];
int top = -1;

void push(int x) {
    if (top == MAX - 1)
        printf("Stack Overflow\n");
    else {
        top++;
        stack[top] = x;
    }
}

void display() {
    if (top == -1)
        printf("Stack is Empty\n");
    else {
        printf("Stack elements are:\n");
        for (int i = top; i >= 0; i--)
            printf("%d\n", stack[i]);
    }
}

int main() {
    push(10);
    push(20);
    push(30);
    display();
    return 0;
}
```

---

## **2Ô∏è‚É£ Program: Stack using Linked List (Pop and Peek)**

### **Algorithm**

```
Step 1: Start
Step 2: Define a node structure with data and next pointer
Step 3: Initialize top = NULL
Step 4: To PUSH an element:
        a. Create a new node
        b. Assign data = element
        c. Link new node‚Äôs next to top
        d. Update top = new node
Step 5: To POP an element:
        a. If top == NULL, display "Underflow"
        b. Else, store top->data in a variable
        c. Move top to top->next
        d. Delete the removed node
        e. Display popped element
Step 6: To PEEK:
        a. If top == NULL, display "Stack is empty"
        b. Else, print top->data
Step 7: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};
struct Node* top = NULL;

void push(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = top;
    top = newNode;
}

void pop() {
    if (top == NULL)
        printf("Stack Underflow\n");
    else {
        struct Node* temp = top;
        printf("Popped element: %d\n", top->data);
        top = top->next;
        free(temp);
    }
}

void peek() {
    if (top == NULL)
        printf("Stack is Empty\n");
    else
        printf("Top element: %d\n", top->data);
}

void display() {
    struct Node* temp = top;
    if (temp == NULL)
        printf("Stack is Empty\n");
    else {
        printf("Stack elements are:\n");
        while (temp != NULL) {
            printf("%d\n", temp->data);
            temp = temp->next;
        }
    }
}

int main() {
    push(10);
    push(20);
    push(30);
    display();
    peek();
    pop();
    display();
    return 0;
}
```

---

## **3Ô∏è‚É£ Program: Linear Queue using Array (Insert and Display)**

### **Algorithm**

```
Step 1: Start
Step 2: Initialize front = 0 and rear = -1
Step 3: To INSERT an element:
        a. Check if rear == MAX - 1
           ‚Üí If yes, display "Queue Overflow"
        b. Else, increment rear by 1
        c. Insert new element at queue[rear]
Step 4: To DISPLAY elements:
        a. If front > rear, display "Queue is empty"
        b. Else, print all elements from front to rear
Step 5: Stop
```

### **C Program**

```c
#include <stdio.h>
#define MAX 100

int queue[MAX];
int front = 0, rear = -1;

void insert(int value) {
    if (rear == MAX - 1)
        printf("Queue Overflow\n");
    else {
        rear++;
        queue[rear] = value;
    }
}

void display() {
    if (front > rear)
        printf("Queue is Empty\n");
    else {
        printf("Queue elements are:\n");
        for (int i = front; i <= rear; i++)
            printf("%d ", queue[i]);
        printf("\n");
    }
}

int main() {
    insert(10);
    insert(20);
    insert(30);
    display();
    return 0;
}
```

---



---

## **4Ô∏è‚É£ Program: Circular Queue using Array (Delete and Display)**

### **Algorithm**

```
Step 1: Start
Step 2: Initialize front = -1 and rear = -1
Step 3: To INSERT an element:
        a. Check if the queue is full:
           - Condition: (front == 0 && rear == MAX-1) OR (rear + 1 == front)
           - If full, display "Queue Overflow"
        b. Else if front == -1, set front = 0, rear = 0
        c. Else, set rear = (rear + 1) % MAX
        d. Insert element at queue[rear]
Step 4: To DELETE an element:
        a. If front == -1, display "Queue Underflow"
        b. Else, print deleted element = queue[front]
        c. If front == rear, set front = rear = -1 (queue becomes empty)
        d. Else, front = (front + 1) % MAX
Step 5: To DISPLAY elements:
        a. If front == -1, display "Queue is empty"
        b. Else, print elements from front to rear circularly
Step 6: Stop
```

### **C Program**

```c
#include <stdio.h>
#define MAX 5

int queue[MAX];
int front = -1, rear = -1;

void insert(int value) {
    if ((front == 0 && rear == MAX - 1) || (rear + 1 == front))
        printf("Queue Overflow\n");
    else {
        if (front == -1)
            front = rear = 0;
        else
            rear = (rear + 1) % MAX;
        queue[rear] = value;
    }
}

void delete() {
    if (front == -1)
        printf("Queue Underflow\n");
    else {
        printf("Deleted element: %d\n", queue[front]);
        if (front == rear)
            front = rear = -1;
        else
            front = (front + 1) % MAX;
    }
}

void display() {
    if (front == -1)
        printf("Queue is Empty\n");
    else {
        int i = front;
        printf("Queue elements are: ");
        while (1) {
            printf("%d ", queue[i]);
            if (i == rear)
                break;
            i = (i + 1) % MAX;
        }
        printf("\n");
    }
}

int main() {
    insert(10);
    insert(20);
    insert(30);
    insert(40);
    display();
    delete();
    display();
    return 0;
}
```

---

## **5Ô∏è‚É£ Program: Singly Linked List (Create, Reverse, Display)**

### **Algorithm**

```
Step 1: Start
Step 2: Define a node structure with data and next pointer
Step 3: Initialize head = NULL
Step 4: To INSERT a node:
        a. Create a new node
        b. Assign data = value, next = NULL
        c. If head == NULL, set head = new node
        d. Else, traverse to last node and link it to new node
Step 5: To REVERSE the list:
        a. Initialize prev = NULL, curr = head
        b. While curr != NULL:
            - next = curr->next
            - curr->next = prev
            - prev = curr
            - curr = next
        c. Set head = prev
Step 6: To DISPLAY:
        a. Traverse from head and print data of each node
Step 7: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};
struct Node* head = NULL;

void insert(int value) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;

    if (head == NULL)
        head = newNode;
    else {
        struct Node* temp = head;
        while (temp->next != NULL)
            temp = temp->next;
        temp->next = newNode;
    }
}

void reverse() {
    struct Node *prev = NULL, *curr = head, *next = NULL;
    while (curr != NULL) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    head = prev;
}

void display() {
    struct Node* temp = head;
    if (temp == NULL)
        printf("List is Empty\n");
    else {
        printf("Linked List: ");
        while (temp != NULL) {
            printf("%d ", temp->data);
            temp = temp->next;
        }
        printf("\n");
    }
}

int main() {
    insert(10);
    insert(20);
    insert(30);
    display();
    reverse();
    display();
    return 0;
}
```

---

## **6Ô∏è‚É£ Program: Singly Linked List (Create, Sort, Display)**

### **Algorithm**

```
Step 1: Start
Step 2: Define node structure with data and next pointer
Step 3: Initialize head = NULL
Step 4: To INSERT a node:
        a. Create a new node with given value
        b. If head == NULL, set head = new node
        c. Else, traverse to last node and link new node
Step 5: To SORT the linked list (Bubble Sort):
        a. Repeat until no swaps occur:
            - Traverse list and compare data of adjacent nodes
            - If current->data > next->data, swap their values
Step 6: To DISPLAY:
        a. Traverse list and print each node‚Äôs data
Step 7: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};
struct Node* head = NULL;

void insert(int value) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;

    if (head == NULL)
        head = newNode;
    else {
        struct Node* temp = head;
        while (temp->next != NULL)
            temp = temp->next;
        temp->next = newNode;
    }
}

void sort() {
    struct Node *i, *j;
    int temp;
    for (i = head; i != NULL; i = i->next) {
        for (j = i->next; j != NULL; j = j->next) {
            if (i->data > j->data) {
                temp = i->data;
                i->data = j->data;
                j->data = temp;
            }
        }
    }
}

void display() {
    struct Node* temp = head;
    if (temp == NULL)
        printf("List is Empty\n");
    else {
        printf("Sorted Linked List: ");
        while (temp != NULL) {
            printf("%d ", temp->data);
            temp = temp->next;
        }
        printf("\n");
    }
}

int main() {
    insert(30);
    insert(10);
    insert(20);
    display();
    sort();
    display();
    return 0;
}
```

---

## **7Ô∏è‚É£ Program: Singly Linked List (Create, Delete a Node, Display)**

### **Algorithm**

```
Step 1: Start
Step 2: Define a node structure with data and next pointer
Step 3: Initialize head = NULL
Step 4: To INSERT a node:
        a. Create a new node and assign data
        b. If head == NULL, set head = new node
        c. Else, link new node at the end of the list
Step 5: To DELETE a node:
        a. If head == NULL, display "List empty"
        b. If head->data == value, delete head and update head = head->next
        c. Else, traverse list keeping track of previous node
        d. If found, unlink and delete that node
Step 6: To DISPLAY:
        a. Traverse from head and print data
Step 7: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};
struct Node* head = NULL;

void insert(int value) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = head;
    head = newNode;
}

void deleteNode(int value) {
    struct Node *temp = head, *prev = NULL;

    if (temp != NULL && temp->data == value) {
        head = temp->next;
        free(temp);
        return;
    }

    while (temp != NULL && temp->data != value) {
        prev = temp;
        temp = temp->next;
    }

    if (temp == NULL)
        printf("Node not found\n");
    else {
        prev->next = temp->next;
        free(temp);
    }
}

void display() {
    struct Node* temp = head;
    if (temp == NULL)
        printf("List is Empty\n");
    else {
        printf("Linked List: ");
        while (temp != NULL) {
            printf("%d ", temp->data);
            temp = temp->next;
        }
        printf("\n");
    }
}

int main() {
    insert(10);
    insert(20);
    insert(30);
    display();
    deleteNode(20);
    display();
    return 0;
}
```


## **8Ô∏è‚É£ Program: Stack using Singly Linked List (SLL)**

### **Algorithm**

```
Step 1: Start
Step 2: Define a structure Node with data and next pointer
Step 3: Initialize top = NULL
Step 4: To PUSH an element:
        a. Create a new node
        b. Assign data = value
        c. Set newNode->next = top
        d. Update top = newNode
Step 5: To POP an element:
        a. If top == NULL, display "Underflow"
        b. Else, store top->data, move top to top->next, and free node
Step 6: To DISPLAY elements:
        a. Traverse from top and print each data
Step 7: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};
struct Node* top = NULL;

void push(int value) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = top;
    top = newNode;
}

void pop() {
    if (top == NULL)
        printf("Stack Underflow\n");
    else {
        struct Node* temp = top;
        printf("Popped: %d\n", top->data);
        top = top->next;
        free(temp);
    }
}

void display() {
    struct Node* temp = top;
    if (temp == NULL)
        printf("Stack is Empty\n");
    else {
        printf("Stack elements are: ");
        while (temp != NULL) {
            printf("%d ", temp->data);
            temp = temp->next;
        }
        printf("\n");
    }
}

int main() {
    push(10);
    push(20);
    push(30);
    display();
    pop();
    display();
    return 0;
}
```

---

## **9Ô∏è‚É£ Program: Evaluate Postfix Expression using Stack**

### **Algorithm**

```
Step 1: Start
Step 2: Initialize an empty stack
Step 3: Read the postfix expression from left to right
Step 4: For each symbol:
        a. If operand ‚Üí push it onto the stack
        b. If operator ‚Üí pop top two operands, apply operation, and push result
Step 5: After the entire expression is scanned, the final result will be at the top of the stack
Step 6: Display the result
Step 7: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <ctype.h>

#define MAX 100
int stack[MAX];
int top = -1;

void push(int x) { stack[++top] = x; }
int pop() { return stack[top--]; }

int main() {
    char exp[100];
    printf("Enter Postfix Expression: ");
    scanf("%s", exp);

    for (int i = 0; exp[i] != '\0'; i++) {
        if (isdigit(exp[i]))
            push(exp[i] - '0');
        else {
            int b = pop();
            int a = pop();
            switch (exp[i]) {
                case '+': push(a + b); break;
                case '-': push(a - b); break;
                case '*': push(a * b); break;
                case '/': push(a / b); break;
            }
        }
    }
    printf("Result = %d\n", pop());
    return 0;
}
```

---

## **üîü Program: Circular Singly Linked List (Insert, Delete, Display)**

### **Algorithm**

```
Step 1: Start
Step 2: Define Node with data and next pointer
Step 3: Initialize head = NULL
Step 4: To INSERT a node:
        a. Create a new node
        b. If head == NULL ‚Üí set newNode->next = newNode, head = newNode
        c. Else, traverse to last node (whose next = head)
        d. Insert new node at end and set its next = head
Step 5: To DELETE a node:
        a. If head == NULL ‚Üí display "Empty"
        b. Traverse and find the node to delete
        c. Adjust links; if deleting head, update head = head->next
        d. Free deleted node
Step 6: To DISPLAY:
        a. Traverse circularly from head and print each node until you return to head
Step 7: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};
struct Node* head = NULL;

void insert(int value) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode->data = value;

    if (head == NULL) {
        head = newNode;
        newNode->next = head;
    } else {
        struct Node* temp = head;
        while (temp->next != head)
            temp = temp->next;
        temp->next = newNode;
        newNode->next = head;
    }
}

void delete(int value) {
    if (head == NULL) {
        printf("List Empty\n");
        return;
    }
    struct Node *temp = head, *prev = NULL;
    if (temp->data == value && temp->next == head) {
        head = NULL;
        free(temp);
        return;
    }
    while (temp->next != head && temp->data != value) {
        prev = temp;
        temp = temp->next;
    }
    if (temp->data == value) {
        if (temp == head) {
            prev = head;
            while (prev->next != head)
                prev = prev->next;
            head = head->next;
            prev->next = head;
        } else
            prev->next = temp->next;
        free(temp);
    }
}

void display() {
    if (head == NULL) {
        printf("List Empty\n");
        return;
    }
    struct Node* temp = head;
    printf("Circular List: ");
    do {
        printf("%d ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("\n");
}

int main() {
    insert(10);
    insert(20);
    insert(30);
    display();
    delete(20);
    display();
    return 0;
}
```

---

## **11Ô∏è‚É£ Program: Doubly Linked List (Insert, Delete, Display)**

### **Algorithm**

```
Step 1: Start
Step 2: Define a structure with data, prev, and next pointers
Step 3: Initialize head = NULL
Step 4: To INSERT a node:
        a. Create a new node
        b. If head == NULL ‚Üí head = new node
        c. Else, traverse to the end and link the node
Step 5: To DELETE a node:
        a. If head == NULL ‚Üí "Empty"
        b. Find node with given value
        c. Adjust pointers of previous and next nodes
        d. Free the node
Step 6: To DISPLAY:
        a. Traverse from head and print data
Step 7: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *prev, *next;
};
struct Node* head = NULL;

void insert(int value) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    newNode->prev = NULL;

    if (head == NULL)
        head = newNode;
    else {
        struct Node* temp = head;
        while (temp->next != NULL)
            temp = temp->next;
        temp->next = newNode;
        newNode->prev = temp;
    }
}

void delete(int value) {
    struct Node* temp = head;
    while (temp != NULL && temp->data != value)
        temp = temp->next;
    if (temp == NULL) return;

    if (temp->prev != NULL)
        temp->prev->next = temp->next;
    else
        head = temp->next;

    if (temp->next != NULL)
        temp->next->prev = temp->prev;

    free(temp);
}

void display() {
    struct Node* temp = head;
    if (temp == NULL) {
        printf("List Empty\n");
        return;
    }
    printf("Doubly Linked List: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    insert(10);
    insert(20);
    insert(30);
    display();
    delete(20);
    display();
    return 0;
}
```

---

## **12Ô∏è‚É£ Program: Binary Search Tree (Insert & Postorder Traversal)**

### **Algorithm**

```
Step 1: Start
Step 2: Define a Node with data, left, and right pointers
Step 3: To INSERT a node:
        a. If tree empty ‚Üí new node = root
        b. Else if value < root->data ‚Üí insert in left subtree
        c. Else insert in right subtree
Step 4: To POSTORDER traverse:
        a. Traverse left subtree
        b. Traverse right subtree
        c. Visit (print) root node
Step 5: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *left, *right;
};

struct Node* newNode(int value) {
    struct Node* node = malloc(sizeof(struct Node));
    node->data = value;
    node->left = node->right = NULL;
    return node;
}

struct Node* insert(struct Node* root, int value) {
    if (root == NULL)
        return newNode(value);
    if (value < root->data)
        root->left = insert(root->left, value);
    else
        root->right = insert(root->right, value);
    return root;
}

void postorder(struct Node* root) {
    if (root == NULL) return;
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->data);
}

int main() {
    struct Node* root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 70);
    insert(root, 20);
    insert(root, 40);
    printf("Postorder: ");
    postorder(root);
    return 0;
}
```

---



## **13Ô∏è‚É£ Program: Binary Search Tree (Insert and Inorder Traversal)**

### **Algorithm**

```
Step 1: Start
Step 2: Define a node structure with data, left, and right pointers
Step 3: Initialize root = NULL
Step 4: To INSERT a node:
        a. If root == NULL, create a new node and assign it to root
        b. If value < root->data, insert in left subtree
        c. Else, insert in right subtree
Step 5: To perform INORDER traversal:
        a. Traverse left subtree
        b. Visit the root node
        c. Traverse right subtree
Step 6: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *left, *right;
};

struct Node* newNode(int value) {
    struct Node* node = malloc(sizeof(struct Node));
    node->data = value;
    node->left = node->right = NULL;
    return node;
}

struct Node* insert(struct Node* root, int value) {
    if (root == NULL)
        return newNode(value);
    if (value < root->data)
        root->left = insert(root->left, value);
    else
        root->right = insert(root->right, value);
    return root;
}

void inorder(struct Node* root) {
    if (root == NULL) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

int main() {
    struct Node* root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 70);
    insert(root, 20);
    insert(root, 40);
    printf("Inorder Traversal: ");
    inorder(root);
    return 0;
}
```

---

## **14Ô∏è‚É£ Program: Binary Search Tree (Insert and Preorder Traversal)**

### **Algorithm**

```
Step 1: Start
Step 2: Define node with data, left, and right pointers
Step 3: Initialize root = NULL
Step 4: To INSERT:
        a. If root == NULL, create new node
        b. If value < root->data, insert in left subtree
        c. Else insert in right subtree
Step 5: To perform PREORDER traversal:
        a. Visit root node
        b. Traverse left subtree
        c. Traverse right subtree
Step 6: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *left, *right;
};

struct Node* newNode(int value) {
    struct Node* node = malloc(sizeof(struct Node));
    node->data = value;
    node->left = node->right = NULL;
    return node;
}

struct Node* insert(struct Node* root, int value) {
    if (root == NULL)
        return newNode(value);
    if (value < root->data)
        root->left = insert(root->left, value);
    else
        root->right = insert(root->right, value);
    return root;
}

void preorder(struct Node* root) {
    if (root == NULL) return;
    printf("%d ", root->data);
    preorder(root->left);
    preorder(root->right);
}

int main() {
    struct Node* root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 70);
    insert(root, 20);
    insert(root, 40);
    printf("Preorder Traversal: ");
    preorder(root);
    return 0;
}
```

---

## **15Ô∏è‚É£ Program: Merge Sort**

### **Algorithm**

```
Step 1: Start
Step 2: Divide the array into two halves until each subarray has one element
Step 3: Merge two sorted halves:
        a. Compare elements of both halves
        b. Copy smaller element into temporary array
Step 4: Repeat until all elements are merged in sorted order
Step 5: Copy back merged array to original
Step 6: Stop
```

### **C Program**

```c
#include <stdio.h>

void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1, n2 = right - mid;
    int L[n1], R[n2];
    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2)
        arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

int main() {
    int arr[] = {38, 27, 43, 3, 9, 82, 10};
    int n = 7;
    mergeSort(arr, 0, n - 1);
    printf("Sorted array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    return 0;
}
```

---

## **16Ô∏è‚É£ Program: Depth First Search (DFS) using Adjacency Matrix**

### **Algorithm**

```
Step 1: Start
Step 2: Represent graph using adjacency matrix
Step 3: Initialize visited[] array as false
Step 4: Choose starting vertex v
Step 5: Mark v as visited and print it
Step 6: For every adjacent vertex u of v:
        a. If u is not visited, recursively call DFS(u)
Step 7: Stop
```

### **C Program**

```c
#include <stdio.h>

void DFS(int v, int n, int adj[10][10], int visited[10]) {
    visited[v] = 1;
    printf("%d ", v);
    for (int i = 0; i < n; i++)
        if (adj[v][i] && !visited[i])
            DFS(i, n, adj, visited);
}

int main() {
    int n = 5;
    int adj[5][5] = {
        {0,1,1,0,0},
        {1,0,0,1,0},
        {1,0,0,1,1},
        {0,1,1,0,1},
        {0,0,1,1,0}
    };
    int visited[5] = {0};
    printf("DFS starting from vertex 0: ");
    DFS(0, n, adj, visited);
    return 0;
}
```

---

## **17Ô∏è‚É£ Program: Selection Sort**

### **Algorithm**

```
Step 1: Start
Step 2: For each position i from 0 to n-2:
        a. Find the minimum element in the unsorted part
        b. Swap it with element at index i
Step 3: Repeat until all elements are sorted
Step 4: Stop
```

### **C Program**

```c
#include <stdio.h>

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int min = i;
        for (int j = i + 1; j < n; j++)
            if (arr[j] < arr[min])
                min = j;
        int temp = arr[min];
        arr[min] = arr[i];
        arr[i] = temp;
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = 5;
    selectionSort(arr, n);
    printf("Sorted array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    return 0;
}
```

---

## **18Ô∏è‚É£ Program: Infix to Postfix Conversion using Stack**

### **Algorithm**

```
Step 1: Start
Step 2: Initialize empty stack and output string
Step 3: Scan infix expression from left to right
Step 4: For each symbol:
        a. If operand ‚Üí add to output
        b. If '(' ‚Üí push to stack
        c. If ')' ‚Üí pop from stack to output until '(' is found
        d. If operator ‚Üí pop from stack while precedence is higher, then push current operator
Step 5: After scanning, pop remaining operators to output
Step 6: Display postfix expression
Step 7: Stop
```

### **C Program**

```c
#include <stdio.h>
#include <ctype.h>

#define MAX 100
char stack[MAX];
int top = -1;

void push(char x) { stack[++top] = x; }
char pop() { return stack[top--]; }
int precedence(char x) {
    if (x == '^') return 3;
    if (x == '*' || x == '/') return 2;
    if (x == '+' || x == '-') return 1;
    return 0;
}

int main() {
    char exp[100], output[100];
    int k = 0;
    printf("Enter Infix Expression: ");
    scanf("%s", exp);

    for (int i = 0; exp[i] != '\0'; i++) {
        char c = exp[i];
        if (isalnum(c))
            output[k++] = c;
        else if (c == '(')
            push(c);
        else if (c == ')') {
            while (stack[top] != '(')
                output[k++] = pop();
            top--;
        } else {
            while (top != -1 && precedence(stack[top]) >= precedence(c))
                output[k++] = pop();
            push(c);
        }
    }
    while (top != -1)
        output[k++] = pop();
    output[k] = '\0';
    printf("Postfix Expression: %s\n", output);
    return 0;
}
```

---

## **19Ô∏è‚É£ Program: Breadth First Search (BFS) using Adjacency Matrix**

### **Algorithm**

```
Step 1: Start
Step 2: Represent graph using adjacency matrix
Step 3: Initialize visited[] as false and a queue
Step 4: Enqueue start vertex and mark as visited
Step 5: While queue not empty:
        a. Dequeue vertex v and print it
        b. For each adjacent vertex u of v:
           - If not visited, mark visited and enqueue
Step 6: Stop
```

### **C Program**

```c
#include <stdio.h>

void BFS(int start, int n, int adj[10][10]) {
    int visited[10] = {0}, queue[10], front = 0, rear = 0;
    visited[start] = 1;
    queue[rear++] = start;

    while (front < rear) {
        int v = queue[front++];
        printf("%d ", v);
        for (int i = 0; i < n; i++) {
            if (adj[v][i] && !visited[i]) {
                queue[rear++] = i;
                visited[i] = 1;
            }
        }
    }
}

int main() {
    int n = 5;
    int adj[5][5] = {
        {0,1,1,0,0},
        {1,0,0,1,0},
        {1,0,0,1,1},
        {0,1,1,0,1},
        {0,0,1,1,0}
    };
    printf("BFS starting from vertex 0: ");
    BFS(0, n, adj);
    return 0;
}
```

---

## **20Ô∏è‚É£ Program: Quick Sort**

### **Algorithm**

```
Step 1: Start
Step 2: Choose the last element as pivot
Step 3: Partition array into two parts:
        a. Elements smaller than pivot on left
        b. Elements greater on right
Step 4: Recursively sort both parts
Step 5: Stop
```

### **C Program**

```c
#include <stdio.h>

void swap(int *a, int *b) {
    int t = *a; *a = *b; *b = t;
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++)
        if (arr[j] <= pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    swap(&arr[i + 1], &arr[high]);
    return i + 1;
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = 6;
    quickSort(arr, 0, n - 1);
    printf("Sorted array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    return 0;
}
```

---

## **21Ô∏è‚É£ Program: Insertion Sort**

### **Algorithm**

```
Step 1: Start
Step 2: Assume first element is sorted
Step 3: Pick the next element (key)
Step 4: Compare key with previous elements and shift greater ones right
Step 5: Insert key at correct position
Step 6: Repeat until array sorted
Step 7: Stop
```

### **C Program**

```c
#include <stdio.h>

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = 5;
    insertionSort(arr, n);
    printf("Sorted array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    return 0;
}
```

---

## **22Ô∏è‚É£ Program: Selection Sort (Simplified)**

### **Algorithm**

```
Step 1: Start
Step 2: For i = 0 to n-2:
        a. Assume i is index of minimum
        b. Find smallest element in unsorted part
        c. Swap it with element at i
Step 3: Stop
```

### **C Program**

```c
#include <stdio.h>

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int min = i;
        for (int j = i + 1; j < n; j++)
            if (arr[j] < arr[min])
                min = j;
        int temp = arr[min];
        arr[min] = arr[i];
        arr[i] = temp;
    }
}

int main() {
    int arr[] = {29, 10, 14, 37, 13};
    int n = 5;
    selectionSort(arr, n);
    printf("Sorted array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    return 0;
}
```

---





